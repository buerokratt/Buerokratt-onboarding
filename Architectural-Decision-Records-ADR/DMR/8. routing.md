# ROUTING-001: Routing and Load Distribution

## Context

Each DMR acts as a secure message relay using **Nginx as its core routing engine**. Messages pass through DMR nodes based on **explicit metadata**, and routing logic must ensure:

- Only authorized and policy-compliant messages are forwarded
- Routing remains stateless, verifiable, and independent of message content
- Load is distributed across valid paths without violating trust boundaries

Because DMRs do not inspect payloads and do not maintain session state, routing must be handled through **Nginx directives and metadata-aware proxying**.

---

## Decision

### 1. Metadata-Driven Routing via Nginx

- Routing is determined by inspecting structured metadata in HTTP headers (e.g., `X-Recipient-ID`, `X-Scope`)
- Nginx configuration must define **routing rules and upstream blocks** that reflect current CentOps topology
- Only requests with valid headers, verified scopes, and matching policy entries are forwarded

### 2. Stateless Operation

- DMRs using Nginx must be stateless:
  - No routing state is preserved between requests
  - Requests are routed based on header inspection alone
- Stateful constructs (e.g. sticky sessions, cookies) are not used

### 3. Load Distribution via Upstream Pools

- Nginx upstreams must support:
  - **Weighted load balancing** for nodes with known capacity differences
  - **Health checks** to detect and bypass unreachable peers
  - **Dynamic DNS or CentOps-generated upstream lists**

- Load balancing strategy must never override metadata validation or policy restrictions

### 4. Topology Injection

- CentOps is responsible for generating:
  - **Nginx upstream configurations** (e.g. via templating or sidecar integration)
  - **Access control maps or variables** to enforce routing permissions
- DMR nodes must reload Nginx with minimal disruption when topology or routing policy changes

---

## Example

### Nginx Upstream Configuration (Generated by CentOps)

```nginx
upstream dmr_cluster_backend {
    server dmr-node-07.example.org weight=3 max_fails=2 fail_timeout=10s;
    server dmr-node-13.example.org weight=1;
}
```

### Nginx Routing Logic (Based on Metadata Headers)

```nginx
map $http_x_recipient_id $route_target {
    default dmr_cluster_backend;
    service-42 dmr-cluster-service-42;
}

server {
    listen 443 ssl http2;

    location /relay {
        if ($http_x_authz_token = "") { return 403; }
        if ($route_target = "") { return 404; }

        proxy_pass https://$route_target;
        proxy_set_header Host $host;
        proxy_set_header X-Forwarded-For $remote_addr;
    }
}
```

---

## Consequences

### **Positive Outcomes**

- **Metadata-Constrained Routing** – Routing is explicitly tied to validated headers, maintaining DMR trust boundaries
- **Nginx Operational Reliability** – DMRs benefit from Nginx’s mature routing, health checking, and configuration hot-reloading
- **Scalable Load Distribution** – Load is distributed across multiple nodes based on policy and capacity weights

### **Potential Trade-offs**

- **Reload Latency** – Topology or config changes require timed reloads, which may introduce brief inconsistencies
- **Limited Internal Logic** – Complex routing conditions must be externalized or templated; no embedded logic inside DMRs
- **Dependency on Accurate Metadata** – Any malformed or missing headers may cause routing failures or message rejection

---

Here is **DMR-007: Resilience and Fault Handling**, focused on how DMRs must handle degraded conditions such as peer failure, invalid configurations, or message rejection, with Nginx as the core.

---

# ROUTING-002: Resilience and Fault Handling

## Context

DMRs must maintain **continuous availability and consistent behavior** in the presence of failures — including upstream node downtime, invalid configuration updates, network partitions, or malformed requests.

While DMRs are stateless and Nginx-based, they still act as critical gatekeepers for secure message forwarding. As such, resilience must be built around:

- Defensive default behavior (fail-closed)
- Peer failure tolerance (without breaking the mesh)
- Safe configuration reloads
- Predictable handling of malformed or unauthorized messages

---

## Decision

### 1. Fail-Closed Authorization Behavior

- If a message lacks required metadata or fails verification:
  - DMR must immediately reject the request
  - No retries or fallback paths should be attempted
- Unauthorized, expired, or unverifiable requests must never be routed further

### 2. Upstream Node Failure Handling

- DMRs must detect failed peer nodes using:
  - Passive health checks (connection failures, 5xx responses)
  - Optional active probes via Nginx
- Failed nodes must be logged
- Requests should be retried with alternate authorized upstreams (if available) based on Nginx’s internal retry logic

### 3. Safe Reload and Rollback on Config Errors

- Nginx configuration must be:
  - Validated before reload using built-in tools (e.g. `nginx -t`)
  - Hot-reloaded with no disruption using `nginx -s reload`
- If a new policy or topology config is invalid or rejected:
  - The last known good configuration must remain in effect
  - DMR must emit a clear log or alert indicating failure to reload

### 4. Controlled Retry and Timeout Strategy

- DMRs must:
  - Define short timeouts for upstream requests (e.g. 1–3s)
  - Limit retry attempts (e.g. max 2 retries per request)
  - Avoid retrying unauthorized or invalid requests

- Retry behavior must never obscure the root cause of errors (e.g. policy violation must not be masked as transient error)

---

## Example

### Nginx Configuration: Timeout and Retry Policy

```nginx
proxy_connect_timeout       2s;
proxy_read_timeout          3s;
proxy_next_upstream         error timeout http_502 http_503 http_504;
proxy_next_upstream_tries   2;
```

### Configuration Validation and Fallback Flow

```yaml
dmr_config:
  policy_reload:
    validate_before_reload: true
    retain_last_valid_config: true
    reject_if_invalid: true
    alert_on_reload_failure: true
```

---

## Consequences

### **Positive Outcomes**

- **Predictable Failure Behavior** – All verification and config errors result in safe, explainable rejection.
- **Mesh Resilience** – Individual node failures do not impact the overall routing capability of the network.
- **Safe Config Evolution** – Bad policy or topology updates cannot corrupt active routing behavior.

### **Potential Trade-offs**

- **False Positives in Node Health** – Brief connection spikes may incorrectly mark a node as down.
- **Operational Complexity** – Requires careful tuning of timeouts and retries to avoid cascading errors.
- **Strict Failure Model** – Overly strict config validation may prevent deployment in ambiguous conditions.
